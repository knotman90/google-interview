\chapter{Distinct Pairs}
Let $A = \{a_1,a_2,...,a_n\}$ s.t. $a_i \neq aj, i \neq j$, $B = \{b_1,b_2,...,b_m\}$ s.t. $b_i \neq b_j, i \neq j$.
Goal of the problem is to find exactly $n+m-1$ ordered pairs of integers $(x_1,y_1) , (x_2,y_2),...,(x_{n+m-1},y_{n+m-1})$ where $x_i$ and $y_i$ represent indexes in $A$ and $B$, respectively s.t. $ A_{x_i} + B_{y_i} \neq  A_{x_j} + B_{y_j} \: : i \neq j$

\section{Constraints}
\label{dist_pairs:constraints}
\begin{itemize}	
	\item $1 \leq  n,m \leq 10^5$
	\item $\abs{a_i},\abs{b_i}  <= 10^{18}$
\end{itemize}

\section{Example}
\label{dist_pairs:example}
Suppose the input consist in the following sequence of integers:
\begin{itemize}
	\item $A = \{-1,2,-5,-3,4,8\}$
	\item $B = \{-3,25,0\}$
\end{itemize}
A valid solution could be the following:
$(2,2), (1,3), (2,3), (6,3), (5,1), (3,2), (4,3), (1,1) $
because the size of the solution is $9$ corresponding to the size of $A$ plus the size of $B$ minus one and 
$ A_2,+B_2 \neq (A_1+B_3)\neq (A_2+B_3) \neq (A_6+B_3) \neq (A_5+B_1) \neq  (A_3+B_2) \neq (A_4+B_3) \neq (A_1+B_1)$

\section{Solution}

\subsection{Brute Force}
The brute force approach would iterate among all pairs of indices and would store them in a set. Each pair is stored in the set if and only if the corresponding sum is not already obtained with another pair already in the set.
This algorithm would run in $O(n \times m)$.
The following code shows a possible implementation of this idea.
\begin{lstlisting}[language=c++, caption="Distinc pair problem. Brute force approach.",label=list:knapexp]

brute force.

\end{lstlisting}

\subsection{Linear Time}
A linear time solution for this problem exists.
Let's denote with $idxA(el)$ the indices of the value $el$ in $A$, with  $idB(el)$ the indices of the value $el$ in $B$ and finally with $sum(x,y)=A_x + B_y$ the sum obtained by summing up the element of $A$ at position $x$ and the element of $B$ at position $y$.
W.r.t. the example shown in Section \ref{dist_pairs:example}, for instance, $idxA(4) = 5$ and $idxB(0) = 3$.
It is sufficient to use the find the indices $maxIdx(A)$ corresponding to the maximum element in $A$ and the index $minIdx(B)$ minimum element in $B$ and generate the following $n+m-1$ pairs:
\begin{equation}
\label{dist_pairs:first_set_indices}
(maxIdx(A), j )\:\: \forall 1 \leq j \leq m
\end{equation}

\begin{equation}
\label{dist_pairs:second_set_indices}
(i, minIdx(B) )\:\: \forall 1 \leq i \leq n,\: i \neq maxIdx(A)
\end{equation}

Note that the pairs generated by \ref{dist_pairs:first_set_indices} are exactly $m$ and the ones generated by \ref{dist_pairs:second_set_indices} are exactly $n-1$. The total number of generated pairs is: $m+n-1$.

Let's prove that no two generated pair can ever have the same sum.
Suppose that two of such pairs exists i.e.:
$sum(maxIdx(A), j) = sum(i, minIdx(B))$ for some $1 \leq i \leq n\;, i \neq maxIdx(A)$ and $1 \leq j \leq m$.
\[A_{maxIdx(A)} + B_j = A_i + B_{minIdx(B)}\]
Since $A_{maxIdx(A)} > A_i$, then $A_i = A_{maxIdx(A)}- k$ for some $k \neq 0$
\[\cancel{A_{maxIdx(A)}} + B_j = \cancel{A_{maxIdx(A)}}- k + B_{minIdx(B)}\]
\[B_j = B_{minIdx(B)} - k\] which is \textbf{impossible} because $B_j > B_{minIdx(B)}$.

The following code implements this idea:
\begin{lstlisting}[language=c++, caption="Distinc pair problem. Brute force approach.",label=list:knapexp]

void solve() {
	int n, m;
	cin >> n >> m;
	vector<pii> N(n);
	vector<pii> M(m);

	for (int i = 0; i < n; i++) {
		cin >> N[i].first;
		N[i].second = i;
	}
	
	for (int i = 0; i < m; i++) {
		cin >> M[i].first;
		M[i].second = i;
	}
	
	auto cmp = [](const auto a, const auto b) { return (a.first < b.first); };
	sort(begin(N), end(N), cmp);
	sort(begin(M), end(M), cmp);
	
	const int bestn = N[N.size() - 1].second;
	
	for (unsigned i = 0; i < M.size(); i++)
		cout << bestn << " " << M[i].second << endl;
	
	for (unsigned i = 0; i < N.size(); i++)
		if (N[i].second != bestn) 
			cout << N[i].second << " " << M[0].second << endl;
}
\end{lstlisting}


